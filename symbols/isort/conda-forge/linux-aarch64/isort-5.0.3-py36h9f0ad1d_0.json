{
 "errors": {
  "isort._future._dataclasses": {
   "exception": "<ForStmt: for line in (             (line.strip() for line in line.split(\";\")) if \";\" in line else (line,)  # type: ignore         ):             line, raw_line = _normalize_line(line)             type_of_import = import_type(line) or \"\"             if not type_of_import:                 out_lines.append(raw_line)                 continue              if import_index == -1:                 import_index = index - 1             nested_comments = {}             import_string, comment = parse_comments(line)             comments = [comment] if comment else []             line_parts = [part for part in _strip_syntax(import_string).strip().split(\" \") if part]             if (                 type_of_import == \"from\"                 and len(line_parts) == 2                 and line_parts[1] != \"*\"                 and comments             ):                 nested_comments[line_parts[-1]] = comments[0]              if \"(\" in line.split(\"#\")[0] and index < line_count:                 while not line.split(\"#\")[0].strip().endswith(\")\") and index < line_count:                     line, new_comment = parse_comments(in_lines[index])                     index += 1                     if new_comment:                         comments.append(new_comment)                     stripped_line = _strip_syntax(line).strip()                     if (                         type_of_import == \"from\"                         and stripped_line                         and \" \" not in stripped_line                         and new_comment                     ):                         nested_comments[stripped_line] = comments[-1]                     import_string += line_separator + line             else:                 while line.strip().endswith(\"\\\\\"):                     line, new_comment = parse_comments(in_lines[index])                     index += 1                     if new_comment:                         comments.append(new_comment)                      # Still need to check for parentheses after an escaped line                     if (                         \"(\" in line.split(\"#\")[0]                         and \")\" not in line.split(\"#\")[0]                         and index < line_count                     ):                         stripped_line = _strip_syntax(line).strip()                         if (                             type_of_import == \"from\"                             and stripped_line                             and \" \" not in stripped_line                             and new_comment                         ):                             nested_comments[stripped_line] = comments[-1]                         import_string += line_separator + line                          while not line.split(\"#\")[0].strip().endswith(\")\") and index < line_count:                             line, new_comment = parse_comments(in_lines[index])                             index += 1                             if new_comment:                                 comments.append(new_comment)                             stripped_line = _strip_syntax(line).strip()                             if (                                 type_of_import == \"from\"                                 and stripped_line                                 and \" \" not in stripped_line                                 and new_comment                             ):                                 nested_comments[stripped_line] = comments[-1]                             import_string += line_separator + line                      stripped_line = _strip_syntax(line).strip()                     if (                         type_of_import == \"from\"                         and stripped_line                         and \" \" not in stripped_line                         and new_comment                     ):                         nested_comments[stripped_line] = comments[-1]                     if import_string.strip().endswith(                         (\" import\", \" cimport\")                     ) or line.strip().startswith((\"import \", \"cimport \")):                         import_string += line_separator + line                     else:                         import_string = import_string.rstrip().rstrip(\"\\\\\") + \" \" + line.lstrip()              if type_of_import == \"from\":                 cimports: bool                 import_string = import_string.replace(\"import(\", \"import (\")                 if \" cimport \" in import_string:                     parts = import_string.split(\" cimport \")                     cimports = True                  else:                     parts = import_string.split(\" import \")                     cimports = False                  from_import = parts[0].split(\" \")                 import_string = (\" cimport \" if cimports else \" import \").join(                     [from_import[0] + \" \" + \"\".join(from_import[1:])] + parts[1:]                 )              just_imports = [                 item.replace(\"{|\", \"{ \").replace(\"|}\", \" }\")                 for item in _strip_syntax(import_string).split()             ]             straight_import = True             if \"as\" in just_imports and (just_imports.index(\"as\") + 1) < len(just_imports):                 straight_import = False                 while \"as\" in just_imports:                     as_index = just_imports.index(\"as\")                     if type_of_import == \"from\":                         module = just_imports[0] + \".\" + just_imports[as_index - 1]                         as_name = just_imports[as_index + 1]                         if as_name not in as_map[module]:                             as_map[module].append(as_name)                     else:                         module = just_imports[as_index - 1]                         as_name = just_imports[as_index + 1]                         if as_name not in as_map[module]:                             as_map[module].append(as_name)                         if \".\" in module:                             type_of_import = \"from\"                             just_imports[:as_index] = module.rsplit(\".\", 1)                             as_index = just_imports.index(\"as\")                     if not config.combine_as_imports:                         categorized_comments[\"straight\"][module] = comments                         comments = []                     del just_imports[as_index : as_index + 2]             if type_of_import == \"from\":                 import_from = just_imports.pop(0)                 placed_module = finder(import_from)                 if config.verbose:                     print(f\"from-type place_module for {import_from} returned {placed_module}\")                 if placed_module == \"\":                     warn(                         f\"could not place module {import_from} of line {line} --\"                         \" Do you need to define a default section?\"                     )                 root = imports[placed_module][type_of_import]  # type: ignore                 for import_name in just_imports:                     associated_comment = nested_comments.get(import_name)                     if associated_comment:                         categorized_comments[\"nested\"].setdefault(import_from, {})[                             import_name                         ] = associated_comment                         if associated_comment in comments:                             comments.pop(comments.index(associated_comment))                 if comments:                     categorized_comments[\"from\"].setdefault(import_from, []).extend(comments)                  if len(out_lines) > max(import_index, 1) - 1:                     last = out_lines and out_lines[-1].rstrip() or \"\"                     while (                         last.startswith(\"#\")                         and not last.endswith('\"\"\"')                         and not last.endswith(\"'''\")                         and \"isort:imports-\" not in last                         and \"isort: imports-\" not in last                     ):                         categorized_comments[\"above\"][\"from\"].setdefault(import_from, []).insert(                             0, out_lines.pop(-1)                         )                         if len(out_lines) > max(import_index - 1, 1) - 1:                             last = out_lines[-1].rstrip()                         else:                             last = \"\"                     if statement_index - 1 == import_index:                         import_index -= len(                             categorized_comments[\"above\"][\"from\"].get(import_from, [])                         )                  if import_from not in root:                     root[import_from] = OrderedDict(                         (module, straight_import) for module in just_imports                     )                 else:                     root[import_from].update(                         (module, straight_import | root[import_from].get(module, False))                         for module in just_imports                     )             else:                 for module in just_imports:                     if comments:                         categorized_comments[\"straight\"][module] = comments                         comments = []                      if len(out_lines) > max(import_index, +1, 1) - 1:                          last = out_lines and out_lines[-1].rstrip() or \"\"                         while (                             last.startswith(\"#\")                             and not last.endswith('\"\"\"')                             and not last.endswith(\"'''\")                             and \"isort:imports-\" not in last                             and \"isort: imports-\" not in last                         ):                             categorized_comments[\"above\"][\"straight\"].setdefault(module, []).insert(                                 0, out_lines.pop(-1)                             )                             if out_lines:                                 last = out_lines[-1].rstrip()                             else:                                 last = \"\"                         if index - 1 == import_index:                             import_index -= len(                                 categorized_comments[\"above\"][\"straight\"].get(module, [])                             )                     placed_module = finder(module)                     if config.verbose:                         print(f\"else-type place_module for {module} returned {placed_module}\")                     if placed_module == \"\":                         warn(                             f\"could not place module {module} of line {line} --\"                             \" Do you need to define a default section?\"                         )                         imports.setdefault(\"\", {\"straight\": OrderedDict(), \"from\": OrderedDict()})                     straight_import |= imports[placed_module][type_of_import].get(  # type: ignore                         module, False                     )                     imports[placed_module][type_of_import][module] = straight_import  # type: ignore@194,8>",
   "traceback": [
    "Traceback (most recent call last):",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 727, in tree_name_to_values",
    "    types = context.predefined_names[node][tree_name.value]",
    "KeyError: <ForStmt: # It's an error to have init=False fields in 'changes'.     # If a field is not in 'changes', read its value from the provided obj.      for f in getattr(obj, _FIELDS).values():         if not f.init:             # Error if this field is specified in changes.             if f.name in changes:                 raise ValueError(                     f\"field {f.name} is declared with \"                     \"init=False, it cannot be specified with \"                     \"replace()\"                 )             continue          if f.name not in changes:             changes[f.name] = getattr(obj, f.name)@1187,4>",
    "",
    "During handling of the above exception, another exception occurred:",
    "",
    "Traceback (most recent call last):",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/symbol_exporter/symbol_inspection.py\", line 36, in single_file_extraction",
    "    path=file_name, project=jedi.Project(\"\".join(top_dir))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/api/helpers.py\", line 488, in wrapper",
    "    return func(self, line, column, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/api/__init__.py\", line 213, in complete",
    "    return completion.complete()",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/api/completion.py\", line 169, in complete",
    "    cached_name, completion_names = self._complete_python(leaf)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/api/completion.py\", line 310, in _complete_python",
    "    completion_names += self._complete_global_scope()",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/api/completion.py\", line 376, in _complete_global_scope",
    "    completion_names += filter.values()",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/filters.py\", line 93, in values",
    "    for name_key in self._used_names",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/utils.py\", line 16, in wrapper",
    "    return list(func(*args, **kwargs))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/filters.py\", line 160, in _convert_names",
    "    for name in names:",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/filters.py\", line 95, in <genexpr>",
    "    _get_definition_names(self._used_names, name_key),",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/filters.py\", line 122, in _filter",
    "    return list(self._check_flows(names))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/filters.py\", line 137, in _check_flows",
    "    origin_scope=self._origin_scope",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/flow_analysis.py\", line 85, in reachability_check",
    "    return _break_check(context, value_scope, first_flow_scope, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/flow_analysis.py\", line 100, in _break_check",
    "    reachable = _check_if(context, flow_node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/flow_analysis.py\", line 120, in _check_if",
    "    types = context.infer_node(node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 254, in _infer_node",
    "    return infer_or_test(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 460, in infer_or_test",
    "    types = context.infer_node(next(iterator))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 197, in _infer_node",
    "    value_set = context.infer_node(first_child)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 184, in _infer_node",
    "    return infer_atom(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 304, in infer_atom",
    "    return context.py__getattribute__(atom, position=position)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in py__getattribute__",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 426, in from_sets",
    "    for set_ in sets:",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in <genexpr>",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/names.py\", line 284, in infer",
    "    self.tree_name",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/__init__.py\", line 21, in wrapper",
    "    return built_functions[public_name](*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/stdlib.py\", line 867, in wrapper",
    "    return func(inference_state, context, tree_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/django.py\", line 177, in wrapper",
    "    result = func(inference_state, context, tree_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 731, in tree_name_to_values",
    "    cn.infer(),",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 375, in infer",
    "    return self.context.infer_node(self.node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 208, in _infer_node",
    "    value_set = infer_trailer(context, value_set, trailer)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 278, in infer_trailer",
    "    return atom_values.execute(args)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 483, in execute",
    "    return ValueSet.from_sets(c.inference_state.execute(c, arguments) for c in self._set)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 426, in from_sets",
    "    for set_ in sets:",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 483, in <genexpr>",
    "    return ValueSet.from_sets(c.inference_state.execute(c, arguments) for c in self._set)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/__init__.py\", line 21, in wrapper",
    "    return built_functions[public_name](*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/stdlib.py\", line 133, in wrapper",
    "    return func(value, arguments=arguments, callback=call)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/stdlib.py\", line 159, in wrapper",
    "    value.inference_state, arguments, clinic_string))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/arguments.py\", line 94, in iterate_argument_clinic",
    "    value_set = NO_VALUES if argument is None else argument.infer()",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/lazy_value.py\", line 48, in infer",
    "    return self.context.infer_node(self.data)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 184, in _infer_node",
    "    return infer_atom(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 304, in infer_atom",
    "    return context.py__getattribute__(atom, position=position)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in py__getattribute__",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 426, in from_sets",
    "    for set_ in sets:",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in <genexpr>",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/__init__.py\", line 21, in wrapper",
    "    return built_functions[public_name](*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/pytest.py\", line 62, in wrapper",
    "    return func(param_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/names.py\", line 519, in infer",
    "    values = dynamic_param_lookup(self.function_value, param.position_index)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/dynamic_params.py\", line 47, in wrapper",
    "    return func(function_value, param_index)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/dynamic_params.py\", line 91, in dynamic_param_lookup",
    "    arguments_list = _search_function_arguments(module_context, funcdef, string_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/utils.py\", line 16, in wrapper",
    "    return list(func(*args, **kwargs))",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/dynamic_params.py\", line 140, in _search_function_arguments",
    "    inference_state, random_context, compare_node, name, trailer):",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/dynamic_params.py\", line 197, in _check_name_for_execution",
    "    for value in inference_state.infer(context, name):",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/__init__.py\", line 180, in infer",
    "    return helpers.infer_call_of_leaf(context, name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/helpers.py\", line 104, in infer_call_of_leaf",
    "    values = context.infer_node(base)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 222, in infer_node",
    "    return infer_node(self, node)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 156, in infer_node",
    "    return _infer_node_if_inferred(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 169, in _infer_node_if_inferred",
    "    return _infer_node_cached(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/cache.py\", line 44, in wrapper",
    "    rv = function(obj, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 174, in _infer_node_cached",
    "    return _infer_node(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 184, in _infer_node",
    "    return infer_atom(context, element)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 304, in infer_atom",
    "    return context.py__getattribute__(atom, position=position)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in py__getattribute__",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/base_value.py\", line 426, in from_sets",
    "    for set_ in sets:",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 75, in <genexpr>",
    "    values = ValueSet.from_sets(name.infer() for name in names)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/names.py\", line 284, in infer",
    "    self.tree_name",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/__init__.py\", line 21, in wrapper",
    "    return built_functions[public_name](*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/stdlib.py\", line 867, in wrapper",
    "    return func(inference_state, context, tree_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/plugins/django.py\", line 177, in wrapper",
    "    result = func(inference_state, context, tree_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 738, in tree_name_to_values",
    "    types = infer_expr_stmt(context, node, tree_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 82, in wrapper",
    "    return func(context, *args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 376, in infer_expr_stmt",
    "    return _infer_expr_stmt(context, stmt, seek_name)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/debug.py\", line 81, in wrapper",
    "    return func(*args, **kwargs)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/syntax_tree.py\", line 450, in _infer_expr_stmt",
    "    left_values = _infer_comparison(context, left_values, operator, t)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/contextlib.py\", line 119, in __exit__",
    "    next(self.gen)",
    "  File \"/usr/share/miniconda/envs/test/lib/python3.7/site-packages/jedi/inference/context.py\", line 159, in predefine_names",
    "    del predefined[flow_scope]",
    "KeyError: <ForStmt: for line in (             (line.strip() for line in line.split(\";\")) if \";\" in line else (line,)  # type: ignore         ):             line, raw_line = _normalize_line(line)             type_of_import = import_type(line) or \"\"             if not type_of_import:                 out_lines.append(raw_line)                 continue              if import_index == -1:                 import_index = index - 1             nested_comments = {}             import_string, comment = parse_comments(line)             comments = [comment] if comment else []             line_parts = [part for part in _strip_syntax(import_string).strip().split(\" \") if part]             if (                 type_of_import == \"from\"                 and len(line_parts) == 2                 and line_parts[1] != \"*\"                 and comments             ):                 nested_comments[line_parts[-1]] = comments[0]              if \"(\" in line.split(\"#\")[0] and index < line_count:                 while not line.split(\"#\")[0].strip().endswith(\")\") and index < line_count:                     line, new_comment = parse_comments(in_lines[index])                     index += 1                     if new_comment:                         comments.append(new_comment)                     stripped_line = _strip_syntax(line).strip()                     if (                         type_of_import == \"from\"                         and stripped_line                         and \" \" not in stripped_line                         and new_comment                     ):                         nested_comments[stripped_line] = comments[-1]                     import_string += line_separator + line             else:                 while line.strip().endswith(\"\\\\\"):                     line, new_comment = parse_comments(in_lines[index])                     index += 1                     if new_comment:                         comments.append(new_comment)                      # Still need to check for parentheses after an escaped line                     if (                         \"(\" in line.split(\"#\")[0]                         and \")\" not in line.split(\"#\")[0]                         and index < line_count                     ):                         stripped_line = _strip_syntax(line).strip()                         if (                             type_of_import == \"from\"                             and stripped_line                             and \" \" not in stripped_line                             and new_comment                         ):                             nested_comments[stripped_line] = comments[-1]                         import_string += line_separator + line                          while not line.split(\"#\")[0].strip().endswith(\")\") and index < line_count:                             line, new_comment = parse_comments(in_lines[index])                             index += 1                             if new_comment:                                 comments.append(new_comment)                             stripped_line = _strip_syntax(line).strip()                             if (                                 type_of_import == \"from\"                                 and stripped_line                                 and \" \" not in stripped_line                                 and new_comment                             ):                                 nested_comments[stripped_line] = comments[-1]                             import_string += line_separator + line                      stripped_line = _strip_syntax(line).strip()                     if (                         type_of_import == \"from\"                         and stripped_line                         and \" \" not in stripped_line                         and new_comment                     ):                         nested_comments[stripped_line] = comments[-1]                     if import_string.strip().endswith(                         (\" import\", \" cimport\")                     ) or line.strip().startswith((\"import \", \"cimport \")):                         import_string += line_separator + line                     else:                         import_string = import_string.rstrip().rstrip(\"\\\\\") + \" \" + line.lstrip()              if type_of_import == \"from\":                 cimports: bool                 import_string = import_string.replace(\"import(\", \"import (\")                 if \" cimport \" in import_string:                     parts = import_string.split(\" cimport \")                     cimports = True                  else:                     parts = import_string.split(\" import \")                     cimports = False                  from_import = parts[0].split(\" \")                 import_string = (\" cimport \" if cimports else \" import \").join(                     [from_import[0] + \" \" + \"\".join(from_import[1:])] + parts[1:]                 )              just_imports = [                 item.replace(\"{|\", \"{ \").replace(\"|}\", \" }\")                 for item in _strip_syntax(import_string).split()             ]             straight_import = True             if \"as\" in just_imports and (just_imports.index(\"as\") + 1) < len(just_imports):                 straight_import = False                 while \"as\" in just_imports:                     as_index = just_imports.index(\"as\")                     if type_of_import == \"from\":                         module = just_imports[0] + \".\" + just_imports[as_index - 1]                         as_name = just_imports[as_index + 1]                         if as_name not in as_map[module]:                             as_map[module].append(as_name)                     else:                         module = just_imports[as_index - 1]                         as_name = just_imports[as_index + 1]                         if as_name not in as_map[module]:                             as_map[module].append(as_name)                         if \".\" in module:                             type_of_import = \"from\"                             just_imports[:as_index] = module.rsplit(\".\", 1)                             as_index = just_imports.index(\"as\")                     if not config.combine_as_imports:                         categorized_comments[\"straight\"][module] = comments                         comments = []                     del just_imports[as_index : as_index + 2]             if type_of_import == \"from\":                 import_from = just_imports.pop(0)                 placed_module = finder(import_from)                 if config.verbose:                     print(f\"from-type place_module for {import_from} returned {placed_module}\")                 if placed_module == \"\":                     warn(                         f\"could not place module {import_from} of line {line} --\"                         \" Do you need to define a default section?\"                     )                 root = imports[placed_module][type_of_import]  # type: ignore                 for import_name in just_imports:                     associated_comment = nested_comments.get(import_name)                     if associated_comment:                         categorized_comments[\"nested\"].setdefault(import_from, {})[                             import_name                         ] = associated_comment                         if associated_comment in comments:                             comments.pop(comments.index(associated_comment))                 if comments:                     categorized_comments[\"from\"].setdefault(import_from, []).extend(comments)                  if len(out_lines) > max(import_index, 1) - 1:                     last = out_lines and out_lines[-1].rstrip() or \"\"                     while (                         last.startswith(\"#\")                         and not last.endswith('\"\"\"')                         and not last.endswith(\"'''\")                         and \"isort:imports-\" not in last                         and \"isort: imports-\" not in last                     ):                         categorized_comments[\"above\"][\"from\"].setdefault(import_from, []).insert(                             0, out_lines.pop(-1)                         )                         if len(out_lines) > max(import_index - 1, 1) - 1:                             last = out_lines[-1].rstrip()                         else:                             last = \"\"                     if statement_index - 1 == import_index:                         import_index -= len(                             categorized_comments[\"above\"][\"from\"].get(import_from, [])                         )                  if import_from not in root:                     root[import_from] = OrderedDict(                         (module, straight_import) for module in just_imports                     )                 else:                     root[import_from].update(                         (module, straight_import | root[import_from].get(module, False))                         for module in just_imports                     )             else:                 for module in just_imports:                     if comments:                         categorized_comments[\"straight\"][module] = comments                         comments = []                      if len(out_lines) > max(import_index, +1, 1) - 1:                          last = out_lines and out_lines[-1].rstrip() or \"\"                         while (                             last.startswith(\"#\")                             and not last.endswith('\"\"\"')                             and not last.endswith(\"'''\")                             and \"isort:imports-\" not in last                             and \"isort: imports-\" not in last                         ):                             categorized_comments[\"above\"][\"straight\"].setdefault(module, []).insert(                                 0, out_lines.pop(-1)                             )                             if out_lines:                                 last = out_lines[-1].rstrip()                             else:                                 last = \"\"                         if index - 1 == import_index:                             import_index -= len(                                 categorized_comments[\"above\"][\"straight\"].get(module, [])                             )                     placed_module = finder(module)                     if config.verbose:                         print(f\"else-type place_module for {module} returned {placed_module}\")                     if placed_module == \"\":                         warn(                             f\"could not place module {module} of line {line} --\"                             \" Do you need to define a default section?\"                         )                         imports.setdefault(\"\", {\"straight\": OrderedDict(), \"from\": OrderedDict()})                     straight_import |= imports[placed_module][type_of_import].get(  # type: ignore                         module, False                     )                     imports[placed_module][type_of_import][module] = straight_import  # type: ignore@194,8>",
    ""
   ]
  }
 },
 "symbols": [
  "isort.__main__",
  "isort.__main__.main",
  "isort.__version__",
  "isort._future",
  "isort._future.__all__",
  "isort._future._dataclasses",
  "isort._future.dataclass",
  "isort._future.field",
  "isort._vendored",
  "isort._vendored.toml.TomlArraySeparatorEncoder",
  "isort._vendored.toml.TomlDecodeError",
  "isort._vendored.toml.TomlDecoder",
  "isort._vendored.toml.TomlEncoder",
  "isort._vendored.toml.TomlNumpyEncoder",
  "isort._vendored.toml.TomlPathlibEncoder",
  "isort._vendored.toml.TomlPreserveCommentDecoder",
  "isort._vendored.toml.TomlPreserveCommentEncoder",
  "isort._vendored.toml.TomlPreserveInlineDictEncoder",
  "isort._vendored.toml.__version__",
  "isort._vendored.toml._spec_",
  "isort._vendored.toml.decoder",
  "isort._vendored.toml.decoder.CommentValue",
  "isort._vendored.toml.decoder.FNFError",
  "isort._vendored.toml.decoder.InlineTableDict",
  "isort._vendored.toml.decoder.TIME_RE",
  "isort._vendored.toml.decoder.TomlDecodeError",
  "isort._vendored.toml.decoder.TomlDecoder",
  "isort._vendored.toml.decoder.TomlPreserveCommentDecoder",
  "isort._vendored.toml.decoder._detect_pathlib_path",
  "isort._vendored.toml.decoder._escape_to_escapedchars",
  "isort._vendored.toml.decoder._escapedchars",
  "isort._vendored.toml.decoder._escapes",
  "isort._vendored.toml.decoder._getpath",
  "isort._vendored.toml.decoder._groupname_re",
  "isort._vendored.toml.decoder._ispath",
  "isort._vendored.toml.decoder._load_date",
  "isort._vendored.toml.decoder._load_unicode_escapes",
  "isort._vendored.toml.decoder._number_with_underscores",
  "isort._vendored.toml.decoder._range",
  "isort._vendored.toml.decoder._strictly_valid_num",
  "isort._vendored.toml.decoder._unescape",
  "isort._vendored.toml.decoder.basestring",
  "isort._vendored.toml.decoder.load",
  "isort._vendored.toml.decoder.unichr",
  "isort._vendored.toml.decoder.unicode",
  "isort._vendored.toml.dump",
  "isort._vendored.toml.dumps",
  "isort._vendored.toml.encoder",
  "isort._vendored.toml.encoder.TomlArraySeparatorEncoder",
  "isort._vendored.toml.encoder.TomlEncoder",
  "isort._vendored.toml.encoder.TomlNumpyEncoder",
  "isort._vendored.toml.encoder.TomlPathlibEncoder",
  "isort._vendored.toml.encoder.TomlPreserveCommentEncoder",
  "isort._vendored.toml.encoder.TomlPreserveInlineDictEncoder",
  "isort._vendored.toml.encoder._dump_float",
  "isort._vendored.toml.encoder._dump_str",
  "isort._vendored.toml.encoder._dump_time",
  "isort._vendored.toml.encoder.dump",
  "isort._vendored.toml.encoder.unicode",
  "isort._vendored.toml.load",
  "isort._vendored.toml.loads",
  "isort._vendored.toml.ordered",
  "isort._vendored.toml.ordered.TomlOrderedDecoder",
  "isort._vendored.toml.ordered.TomlOrderedEncoder",
  "isort._vendored.toml.tz",
  "isort._vendored.toml.tz.TomlTz",
  "isort._version",
  "isort._version.__version__",
  "isort.api",
  "isort.api.CIMPORT_IDENTIFIERS",
  "isort.api.COMMENT_INDICATORS",
  "isort.api.IMPORT_START_IDENTIFIERS",
  "isort.api._config",
  "isort.api._sort_imports",
  "isort.api.check_code_string",
  "isort.api.check_file",
  "isort.api.check_stream",
  "isort.api.sort_code_string",
  "isort.api.sort_file",
  "isort.api.sort_stream",
  "isort.check_code",
  "isort.check_file",
  "isort.check_stream",
  "isort.code",
  "isort.comments",
  "isort.comments.add_to_line",
  "isort.comments.parse",
  "isort.deprecated",
  "isort.deprecated.finders",
  "isort.deprecated.finders.BaseFinder",
  "isort.deprecated.finders.Config",
  "isort.deprecated.finders.DefaultFinder",
  "isort.deprecated.finders.FindersManager",
  "isort.deprecated.finders.ForcedSeparateFinder",
  "isort.deprecated.finders.KNOWN_SECTION_MAPPING",
  "isort.deprecated.finders.KnownPatternFinder",
  "isort.deprecated.finders.LocalFinder",
  "isort.deprecated.finders.PathFinder",
  "isort.deprecated.finders.Pipfile",
  "isort.deprecated.finders.PipfileFinder",
  "isort.deprecated.finders.ReqsBaseFinder",
  "isort.deprecated.finders.RequirementsFinder",
  "isort.deprecated.finders.chdir",
  "isort.deprecated.finders.exists_case_sensitive",
  "isort.deprecated.finders.parse_requirements",
  "isort.deprecated.finders.pipreqs",
  "isort.deprecated.finders.sections",
  "isort.exceptions",
  "isort.exceptions.ExistingSyntaxErrors",
  "isort.exceptions.FileSkipComment",
  "isort.exceptions.FileSkipSetting",
  "isort.exceptions.FileSkipped",
  "isort.exceptions.ISortError",
  "isort.exceptions.IntroducedSyntaxErrors",
  "isort.exceptions.ProfileDoesNotExist",
  "isort.file",
  "isort.format",
  "isort.format.ask_whether_to_apply_changes_to_file",
  "isort.format.format_natural",
  "isort.format.format_simplified",
  "isort.format.remove_whitespace",
  "isort.format.show_unified_diff",
  "isort.hooks",
  "isort.hooks.api",
  "isort.hooks.get_lines",
  "isort.hooks.get_output",
  "isort.hooks.git_hook",
  "isort.io",
  "isort.io.Empty",
  "isort.io.File",
  "isort.io._ENCODING_PATTERN",
  "isort.io._EmptyIO",
  "isort.logo",
  "isort.logo.ASCII_ART",
  "isort.logo.__doc__",
  "isort.main",
  "isort.main.QUICK_GUIDE",
  "isort.main.SortAttempt",
  "isort.main._build_arg_parser",
  "isort.main._preconvert",
  "isort.main.is_python_file",
  "isort.main.iter_source_code",
  "isort.main.main",
  "isort.main.parse_args",
  "isort.main.shebang_re",
  "isort.main.sort_imports",
  "isort.output",
  "isort.output.STATEMENT_DECLERATIONS",
  "isort.output._normalize_empty_lines",
  "isort.output._output_as_string",
  "isort.output._with_from_imports",
  "isort.output._with_straight_imports",
  "isort.output.format_simplified",
  "isort.output.sorted_imports",
  "isort.parse",
  "isort.parse.CommentsAboveDict",
  "isort.parse.CommentsDict",
  "isort.parse.ParsedContent",
  "isort.parse._infer_line_separator",
  "isort.parse._normalize_line",
  "isort.parse._strip_syntax",
  "isort.parse.file_contents",
  "isort.parse.import_type",
  "isort.parse.skip_line",
  "isort.place",
  "isort.place.Config",
  "isort.place.DEFAULT_CONFIG",
  "isort.place.LOCAL",
  "isort.place._forced_separate",
  "isort.place._is_module",
  "isort.place._is_package",
  "isort.place._known_pattern",
  "isort.place._local",
  "isort.place._src_path",
  "isort.place.exists_case_sensitive",
  "isort.place.module",
  "isort.place.sections",
  "isort.place_module",
  "isort.profiles",
  "isort.profiles.attrs",
  "isort.profiles.black",
  "isort.profiles.django",
  "isort.profiles.google",
  "isort.profiles.hug",
  "isort.profiles.open_stack",
  "isort.profiles.plone",
  "isort.profiles.profiles",
  "isort.profiles.pycharm",
  "isort.pylama_isort",
  "isort.pylama_isort.Linter",
  "isort.pylama_isort.supress_stdout",
  "isort.sections",
  "isort.sections.DEFAULT",
  "isort.sections.FIRSTPARTY",
  "isort.sections.FUTURE",
  "isort.sections.LOCALFOLDER",
  "isort.sections.STDLIB",
  "isort.sections.THIRDPARTY",
  "isort.settings",
  "isort.settings.CONFIG_SECTIONS",
  "isort.settings.CONFIG_SOURCES",
  "isort.settings.Config",
  "isort.settings.DEFAULT_CONFIG",
  "isort.settings.FALLBACK_CONFIG_SECTIONS",
  "isort.settings.FILE_SKIP_COMMENTS",
  "isort.settings.IMPORT_HEADING_PREFIX",
  "isort.settings.KNOWN_PREFIX",
  "isort.settings.KNOWN_SECTION_MAPPING",
  "isort.settings.MAX_CONFIG_SEARCH_DEPTH",
  "isort.settings.RUNTIME_SOURCE",
  "isort.settings.STOP_CONFIG_SEARCH_ON_DIRS",
  "isort.settings.SUPPORTED_EXTENSIONS",
  "isort.settings.VALID_PY_TARGETS",
  "isort.settings._Config",
  "isort.settings._DEFAULT_SETTINGS",
  "isort.settings._abspaths",
  "isort.settings._as_list",
  "isort.settings._find_config",
  "isort.settings._get_config_data",
  "isort.settings._get_str_to_type_converter",
  "isort.setuptools_commands",
  "isort.setuptools_commands.ISortCommand",
  "isort.sorting",
  "isort.sorting._atoi",
  "isort.sorting._import_line_intro_re",
  "isort.sorting._import_line_midline_import_re",
  "isort.sorting._natural_keys",
  "isort.sorting.module_key",
  "isort.sorting.naturally",
  "isort.sorting.section_key",
  "isort.stdlibs",
  "isort.stdlibs.all",
  "isort.stdlibs.all.stdlib",
  "isort.stdlibs.py2",
  "isort.stdlibs.py2.stdlib",
  "isort.stdlibs.py27",
  "isort.stdlibs.py27.stdlib",
  "isort.stdlibs.py3",
  "isort.stdlibs.py3.stdlib",
  "isort.stdlibs.py35",
  "isort.stdlibs.py35.stdlib",
  "isort.stdlibs.py36",
  "isort.stdlibs.py36.stdlib",
  "isort.stdlibs.py37",
  "isort.stdlibs.py37.stdlib",
  "isort.stdlibs.py38",
  "isort.stdlibs.py38.stdlib",
  "isort.stdlibs.py39",
  "isort.stdlibs.py39.stdlib",
  "isort.stream",
  "isort.utils",
  "isort.utils.chdir",
  "isort.utils.exists_case_sensitive",
  "isort.wrap",
  "isort.wrap._wrap_line",
  "isort.wrap.import_statement",
  "isort.wrap.line",
  "isort.wrap_modes",
  "isort.wrap_modes.WrapModes",
  "isort.wrap_modes._wrap_mode",
  "isort.wrap_modes.formatter_from_string",
  "isort.wrap_modes.from_string",
  "isort.wrap_modes.grid",
  "isort.wrap_modes.hanging_indent",
  "isort.wrap_modes.noqa",
  "isort.wrap_modes.vertical"
 ]
}